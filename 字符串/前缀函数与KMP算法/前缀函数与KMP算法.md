# 前缀函数

对于长度为n的字符串s，前缀函数为长度为n的一个数组，其中数中的每一位对应0-i的子串的最长真前缀的长度，其中，一个字符串的真前缀是其前缀且等于后缀但不等于该字符串自身。

举例来说，字符串 abcabcd 的前缀函数为【0，0，0，1，2，3，0】  ，字符串 aabaaab 的前缀函数为 【0，1，0，1，2，2，3】。

朴素算法(bad)(O(n^3))：

```cpp
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 0; i < n; ++i)
    {
        for(int k = 0; k <= i; k++) {
            if(s.substr(0, k) == s.substr(i-k+1, k))
                pi[i] = k;
        }
    }
    return pi;
}
```

优化后算法(O(n)):

关键在于 j = pi[j-1]，理解前段等于后段后，前段的前半段要等于后段的后半段，再考虑结尾处是否相等。

```cpp
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for(int i=1; i<n; i++) {
        int j = pi[i-1];
        while(j > 0 && s[i] != s[j]) j = pi[j-1];
        if(s[i] == s[j]) j++;
        pi[i] = j;
    }
    return pi;
}
```

# 应用：

## 在字符串中查找子串：KMP算法

给定一个文本t和一个字符串s，我们尝试找到并展示s在t中的所有出现（occurrence）。

该任务是前缀函数的一个典型应用。

我们构建一个字符串s+#+t，其中#为既不出现在s中也不出现在t中的分隔符，接下来就是计算该字符串的前缀函数。

由于分隔符的存在，前缀函数某个位置的值不会超过s的长度n。

而如果前缀函数某个位置的值等于n，就意味着s完整地出现在该位置。

（注意该位置下标是针对字符串s+#+t的）

（对应下标转换：i-(n-1)-(n+1)=i-2n）

# 统计每个前缀的出现次数：

## 问题一： 统计s中每个前缀s[0...i]在同一字符串的出现次数。

给定一个长度为j的前缀，同时其也是一个右端点位于i的后缀，下一个更小的前缀长度k小于j为Π[j-1]、Π[Π[j-1]-1]等等的前缀，直到长度变为0。

```cpp
vetor<int> ans(n+1);
for(int i=0; i<n; i++) ans[pi[i]]++; // 统计每个前缀函数值在数组Π中出现了多少次
for(int i=n-1; i>0; i--) ans[pi[i-1]] += ans[i]; // 小的前缀要加上在比它大的前缀中被覆盖住的那些小的前缀
for(int i=0; i<=n; i++) ans[i]++; // 统计原始的前缀，我们对每个结果加1
```

## 问题二： 统计每个前缀s[0...i]在另一个给定字符串t中的出现次数。

构造一个字符串s+#+t并计算其前缀函数。与第一个问题唯一的不同之处在于，我们只关心与字符串t 相关的前缀函数值，即i>=n+1的Π[i] 有了这些值之后，我们可以同样应用在第一个问题中的算法来解决该问题。

